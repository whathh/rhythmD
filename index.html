<!DOCTYPE html>
<html lang="en" >
<head>
Â  <meta charset="UTF-8" />
Â  <title>Rhythm Trainer with h-Subdivision Typing</title>
Â  <style>
Â  Â  body {
Â  Â  Â  font-family: Arial, sans-serif;
Â  Â  Â  background: #f9f9f9;
Â  Â  Â  text-align: center;
Â  Â  Â  margin: 20px;
Â  Â  }
Â  Â  h1 {
Â  Â  Â  margin-bottom: 10px;
Â  Â  }
Â  Â  #baseNote {
Â  Â  Â  font-size: 80px;
Â  Â  Â  margin-bottom: 10px;
Â  Â  }
#notes {
Â  Â  Â  /* Changed from grid to flex for better horizontal flow */
Â  Â  Â  display: flex; 
Â  Â  Â  flex-direction: row; 
Â  Â  Â  
Â  Â  Â  /* Allows items to wrap onto the next line if the screen is too narrow */
Â  Â  Â  flex-wrap: wrap; 
Â  Â  Â  
Â  Â  Â  /* Centers the entire block of notes horizontally */
Â  Â  Â  justify-content: center; 
Â  Â  Â  
Â  Â  Â  /* Added gap for spacing between notes */
Â  Â  Â  gap: 15px; 
Â  Â  Â  
Â  Â  Â  /* Ensures it uses most of the screen width */
Â  Â  Â  max-width: 95vw; 
Â  Â  Â  margin: 0 auto 15px;
Â  Â  }
Â  Â  .note {
Â  Â  Â  font-size: 40px;
Â  Â  Â  user-select: none;
Â  Â  }
Â  Â  .answer {
Â  Â  Â  width: 80px;
Â  Â  Â  padding: 6px;
Â  Â  Â  font-size: 20px;
Â  Â  Â  text-align: center;
Â  Â  Â  border-radius: 4px;
Â  Â  Â  border: 1.5px solid #ccc;
Â  Â  Â  transition: border-color 0.3s;
Â  Â  }
Â  Â  .answer:focus {
Â  Â  Â  border-color: #0b76ef;
Â  Â  Â  outline: none;
Â  Â  }
Â  Â  .correct {
Â  Â  Â  color: black;
Â  Â  Â  border-color: #2d8f2d !important;
Â  Â  }
Â  Â  .wrong {
Â  Â  Â  color: red;
Â  Â  Â  border-color: red !important;
Â  Â  }
Â  Â  .correctAnswer {
Â  Â  Â  font-size: 14px;
Â  Â  Â  margin-top: 6px;
Â  Â  Â  user-select: none;
Â  Â  }
Â  Â  #controls {
Â  Â  Â  margin-bottom: 15px;
Â  Â  }
Â  Â  #timer {
Â  Â  Â  font-size: 24px;
Â  Â  Â  font-weight: bold;
Â  Â  Â  margin-bottom: 15px;
Â  Â  Â  user-select: none;
Â  Â  }
Â  Â  #result, #score {
Â  Â  Â  font-size: 18px;
Â  Â  Â  margin-top: 8px;
Â  Â  Â  user-select: none;
Â  Â  }
Â  Â  button {
Â  Â  Â  background-color: #0b76ef;
Â  Â  Â  color: white;
Â  Â  Â  border: none;
Â  Â  Â  padding: 10px 18px;
Â  Â  Â  border-radius: 8px;
Â  Â  Â  cursor: pointer;
Â  Â  Â  margin: 0 10px;
Â  Â  Â  font-size: 16px;
Â  Â  Â  user-select: none;
Â  Â  }
Â  Â  button:hover {
Â  Â  Â  background-color: #095aba;
Â  Â  }
Â  </style>
</head>
<body>

Â  <h1>ðŸŽµ Rhythm Trainer</h1>
Â  <div id="baseNote" title="Base note (quarter = 1 beat)"></div>
Â  <div id="timer">Timer: 0.00 s</div>
Â  <div id="notes"></div>

Â  <div id="controls">
Â  Â  <button id="startBtn">Start New (N)</button>
Â  Â  <button id="submitBtn">Submit (Enter)</button>
Â  </div>

Â  <div id="result"></div>
Â  <div id="score"></div>

Â  <script>
Â  Â  const REGULAR_NOTES = [
Â  Â  Â  { sym: 'ð…', dur: 4 },
Â  Â  Â  { sym: 'ð…—ð…¥', dur: 2 },
Â  Â  Â  { sym: 'ð…˜ð…¥', dur: 1 },
Â  Â  Â  { sym: 'ð…˜ð…¥ð…®', dur: 0.5 },
Â  Â  Â  { sym: 'ð…˜ð…¥ð…¯', dur: 0.25 },
Â  Â  Â  { sym: 'ð…˜ð…¥ð…°', dur: 0.125 },
Â  Â  Â  { sym: 'ð…˜ð…¥ð…±', dur: 0.0625 }
Â  Â  ];

Â  Â  const DOTTED_NOTES = [
Â  Â  Â  { sym: 'ð…â€¢', dur: 6 },
Â  Â  Â  { sym: 'ð…—ð…¥â€¢', dur: 3 },
Â  Â  Â  { sym: 'ð…˜ð…¥â€¢', dur: 1.5 },
Â  Â  Â  { sym: 'ð…˜ð…¥ð…®â€¢', dur: 0.75 },
Â  Â  Â  { sym: 'ð…˜ð…¥ð…¯â€¢', dur: 0.375 }
Â  Â  ];

Â  Â  const BASE_NOTES = [
Â  Â  Â  { sym: 'ð…˜ð…¥', dur: 1 },
Â  Â  Â  { sym: 'ð…˜ð…¥ð…®', dur: 0.5 },
Â  Â  Â  { sym: 'ð…˜ð…¥ð…¯', dur: 0.25 },
Â  Â  Â  { sym: 'ð…˜ð…¥ð…°', dur: 0.125 },
Â  Â  Â  { sym: 'ð…˜ð…¥ð…±', dur: 0.0625 }
Â  Â  ];

Â  Â  const ALLOWED_BASE_FRACTIONS = [
Â  Â  Â  1.5, 1.25, 1.125,
Â  Â  Â  1, 0.75, 0.5, 0.375, 0.25, 0.125, 0.0625
Â  Â  ];

Â  Â  const COUNT = 20;
Â  Â  let baseNote = null;
Â  Â  let questionNotes = [];
Â  Â  let startTime = null;
Â  Â  let timerInterval = null;
Â  Â  let highScore = Number(localStorage.getItem('rhythmHighScore') || 0);
Â  Â  let bestTime = Number(localStorage.getItem('rhythmBestTime') || 0);

Â  Â  const baseNoteDiv = document.getElementById('baseNote');
Â  Â  const notesDiv = document.getElementById('notes');
Â  Â  const timerDiv = document.getElementById('timer');
Â  Â  const resultDiv = document.getElementById('result');
Â  Â  const scoreDiv = document.getElementById('score');
Â  Â  const startBtn = document.getElementById('startBtn');
Â  Â  const submitBtn = document.getElementById('submitBtn');

Â  Â  // ------------------------ UPDATED H-SYSTEM ------------------------
Â  Â  // smallestUnit is no longer needed as the base note duration serves as the unit (1)

Â  Â  // Step 1: convert duration -> h pattern (Duration relative to the base note)
Â  Â  function durationToH(noteDuration) {
Â  Â  Â  // Calculate the ratio of the note's duration to the base note's duration
Â  Â  Â  if (!baseNote) return "";
Â  Â  Â  
Â  Â  Â  const ratio = noteDuration / baseNote.dur;
Â  Â  Â  // Use nearestAllowedAnswer's result for perfect match
Â  Â  Â  const count = nearestAllowedAnswer(ratio);

Â  Â  Â  // We only use h-system for integer or simple half/quarter ratios of the base note.
Â  Â  Â  // To generate a clean 'h' pattern for fractions, we find the smallest denominator (2, 4, 8) 
Â  Â  Â  // and scale the numerator. E.g., 1.5 = 3/2. We'll use 2 as the subdivision.
Â  Â  Â  const subDivisor = Math.pow(2, Math.ceil(Math.log2(1/count))); // E.g., for 0.25, subDivisor is 4
Â  Â  Â  
Â  Â  Â  // Check if it's a simple binary fraction (like 1, 0.5, 1.5, 2, 0.25, etc.)
Â  Â  Â  if (Math.abs(count - Math.round(count)) < 0.0001) {
Â  Â  Â  Â  // Integer answers (e.g., 4) -> hhhh
Â  Â  Â  Â  return Array(Math.round(count)).fill("h").join(" ");
Â  Â  Â  } else if (Math.abs(count * 2 - Math.round(count * 2)) < 0.0001) {
Â  Â  Â  Â  // Half-note answers (e.g., 1.5 = 3/2) -> hhh (where 'h' is 1/2 of base)
Â  Â  Â  Â  return Array(Math.round(count * 2)).fill("h").join(" ");
Â  Â  Â  } else if (Math.abs(count * 4 - Math.round(count * 4)) < 0.0001) {
Â  Â  Â  Â  // Quarter-note answers (e.g., 1.25 = 5/4) -> hhhhh (where 'h' is 1/4 of base)
Â  Â  Â  Â  return Array(Math.round(count * 4)).fill("h").join(" ");
Â  Â  Â  } else {
Â  Â  Â  Â  return "N/A";
Â  Â  Â  }
Â  Â  }

Â  Â  // Step 2: parse "hhh hhh" -> duration (The result is the numerical ratio itself)
Â  Â  function parseHPattern(str) {
Â  Â  Â  str = str.trim();
Â  Â  Â  if (!str) return NaN;
Â  Â  Â  if (!/^[h\s]+$/i.test(str)) return NaN;
Â  Â  Â  
Â  Â  Â  // Count the number of 'h's
Â  Â  Â  let hCount = (str.match(/h/gi) || []).length;

Â  Â  Â  // Find the smallest possible denominator that yields one of the ALLOWED_BASE_FRACTIONS
Â  Â  Â  // This ensures 'h' is always interpreted as the smallest intended subdivision (1/4, 1/2, or 1)
Â  Â  Â  // Since the question is based on integer answers relative to the base, we first check for an exact integer match.
Â  Â  Â  if (ALLOWED_BASE_FRACTIONS.includes(hCount)) return hCount;

Â  Â  Â  // Check for half (e.g., hCount=3 means 3/2 = 1.5)
Â  Â  Â  if (ALLOWED_BASE_FRACTIONS.includes(hCount / 2)) return hCount / 2;

Â  Â  Â  // Check for quarter (e.g., hCount=5 means 5/4 = 1.25)
Â  Â  Â  if (ALLOWED_BASE_FRACTIONS.includes(hCount / 4)) return hCount / 4;

Â  Â  Â  // Fallback: Assume 'h' is 1/4 of the base, as it covers the most common fractions (1, 0.5, 0.25, 0.75, 1.25, 1.5, 1.75, 2, etc.)
Â  Â  Â  return hCount / 4; 
Â  Â  }

Â  Â  // Step 3: override parseAnswer to handle H-typing
Â  Â  function parseAnswer(inputStr) {
Â  Â  Â  inputStr = inputStr.trim();
Â  Â  Â  // first check H-system
Â  Â  Â  const hVal = parseHPattern(inputStr);
Â  Â  Â  
Â  Â  Â  // If hVal is a reasonable number (not NaN, and not 0 unless 0 is the intended answer)
Â  Â  Â  if (!isNaN(hVal) && (hVal !== 0 || inputStr.toLowerCase().includes('h'))) return hVal;
Â  Â  Â  
Â  Â  Â  // then fraction
Â  Â  Â  if (inputStr.includes('/')) {
Â  Â  Â  Â  const parts = inputStr.split('/');
Â  Â  Â  Â  if (parts.length === 2) {
Â  Â  Â  Â  Â  const numerator = parseFloat(parts[0]);
Â  Â  Â  Â  Â  const denominator = parseFloat(parts[1]);
Â  Â  Â  Â  Â  if (!isNaN(numerator) && !isNaN(denominator) && denominator !== 0) {
Â  Â  Â  Â  Â  Â  return numerator / denominator;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return NaN;
Â  Â  Â  }
Â  Â  Â  // decimal
Â  Â  Â  return parseFloat(inputStr);
Â  Â  }
Â  Â  // ------------------------ END UPDATED H-SYSTEM ------------------------

Â  Â  function shuffleArray(array) {
Â  Â  Â  for(let i = array.length - 1; i > 0; i--) {
Â  Â  Â  Â  const j = Math.floor(Math.random() * (i + 1));
Â  Â  Â  Â  [array[i], array[j]] = [array[j], array[i]];
Â  Â  Â  }
Â  Â  Â  return array;
Â  Â  }

Â  Â  function pickRandomBaseNote() {
Â  Â  Â  return BASE_NOTES[Math.floor(Math.random() * BASE_NOTES.length)];
Â  Â  }

Â  Â  function nearestAllowedAnswer(val) {
Â  Â  Â  let bestDiff = Infinity;
Â  Â  Â  let bestVal = val;

Â  Â  Â  // Check for simple integer first, as many answers will be 1, 2, 4, 8, etc.
Â  Â  Â  const roundedInt = Math.round(val);
Â  Â  Â  if (Math.abs(val - roundedInt) < 0.0001) return roundedInt;

Â  Â  Â  const maxMult = Math.ceil(val) + 2; // Check slightly above the value

Â  Â  Â  for (let mult = 1; mult <= maxMult; mult++) {
Â  Â  Â  Â  for (const frac of ALLOWED_BASE_FRACTIONS) {
Â  Â  Â  Â  Â  const candidate = mult * frac;
Â  Â  Â  Â  Â  const diff = Math.abs(val - candidate);
Â  Â  Â  Â  Â  if (diff < bestDiff) {
Â  Â  Â  Â  Â  Â  bestDiff = diff;
Â  Â  Â  Â  Â  Â  bestVal = candidate;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  return bestVal;
Â  Â  }

Â  Â  function decimalToFraction(value, maxDenominator=64) {
Â  Â  Â  if(value === 0) return "0";

Â  Â  Â  const sign = value < 0 ? "-" : "";
Â  Â  Â  value = Math.abs(value);

Â  Â  Â  let bestNumerator = 1;
Â  Â  Â  let bestDenominator = 1;
Â  Â  Â  let bestError = Math.abs(value - bestNumerator / bestDenominator);

Â  Â  Â  for(let denominator = 1; denominator <= maxDenominator; denominator++) {
Â  Â  Â  Â  let numerator = Math.round(value * denominator);
Â  Â  Â  Â  let error = Math.abs(value - numerator / denominator);
Â  Â  Â  Â  if(error < bestError) {
Â  Â  Â  Â  Â  bestNumerator = numerator;
Â  Â  Â  Â  Â  bestDenominator = denominator;
Â  Â  Â  Â  Â  bestError = error;
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  function gcd(a,b) {
Â  Â  Â  Â  if(!b) return a;
Â  Â  Â  Â  return gcd(b, a % b);
Â  Â  Â  }
Â  Â  Â  let gcdVal = gcd(bestNumerator, bestDenominator);
Â  Â  Â  bestNumerator /= gcdVal;
Â  Â  Â  bestDenominator /= gcdVal;

Â  Â  Â  if(bestNumerator >= bestDenominator) {
Â  Â  Â  Â  let whole = Math.floor(bestNumerator / bestDenominator);
Â  Â  Â  Â  let remainder = bestNumerator % bestDenominator;
Â  Â  Â  Â  if(remainder === 0) return sign + whole.toString();
Â  Â  Â  Â  else return sign + whole + " " + remainder + "/" + bestDenominator;
Â  Â  Â  } else {
Â  Â  Â  Â  return sign + bestNumerator + "/" + bestDenominator;
Â  Â  Â  }
Â  Â  }

Â  Â  function filterNotesByMaxAnswer(notes, baseDur, maxAnswer) {
Â  Â  Â  return notes.filter(n => (n.dur / baseDur) <= maxAnswer);
Â  Â  }

Â  Â  function startQuiz() {
Â  Â  Â  if(timerInterval) clearInterval(timerInterval);
Â  Â  Â  startTime = performance.now();
Â  Â  Â  timerDiv.textContent = "Timer: 0.00 s";

Â  Â  Â  baseNote = pickRandomBaseNote();
Â  Â  Â  baseNoteDiv.textContent = baseNote.sym;
Â  Â  Â  baseNoteDiv.title = `Base note duration: ${baseNote.dur} beats (base note = 1 second)`;

Â  Â  Â  const MAX_ANSWER = 16;

Â  Â  Â  const filteredRegular = filterNotesByMaxAnswer(REGULAR_NOTES, baseNote.dur, MAX_ANSWER);
Â  Â  Â  const filteredDotted = filterNotesByMaxAnswer(DOTTED_NOTES, baseNote.dur, MAX_ANSWER);

Â  Â  Â  const safeRegular = filteredRegular.length >= (COUNT - 6) ? filteredRegular : REGULAR_NOTES;
Â  Â  Â  const safeDotted = filteredDotted.length >= 2 ? filteredDotted : DOTTED_NOTES;

Â  Â  Â  const dottedCount = 2 + Math.floor(Math.random() * 5);
Â  Â  Â  const selectedDotted = [];
Â  Â  Â  for(let i = 0; i < dottedCount; i++) {
Â  Â  Â  Â  selectedDotted.push(safeDotted[Math.floor(Math.random() * safeDotted.length)]);
Â  Â  Â  }
Â  Â  Â  const regularCount = COUNT - dottedCount;
Â  Â  Â  const selectedRegular = [];
Â  Â  Â  for(let i = 0; i < regularCount; i++) {
Â  Â  Â  Â  selectedRegular.push(safeRegular[Math.floor(Math.random() * safeRegular.length)]);
Â  Â  Â  }

Â  Â  Â  questionNotes = shuffleArray(selectedDotted.concat(selectedRegular));

Â  Â  Â  notesDiv.innerHTML = "";
Â  Â  Â  for(let i=0; i<COUNT; i++) {
Â  Â  Â  Â  const q = questionNotes[i];

Â  Â  Â  Â  const container = document.createElement('div');
Â  Â  Â  Â  container.style.display = 'flex';
Â  Â  Â  Â  container.style.flexDirection = 'column';
Â  Â  Â  Â  container.style.alignItems = 'center';

Â  Â  Â  Â  const noteLabel = document.createElement('div');
Â  Â  Â  Â  noteLabel.className = 'note';
Â  Â  Â  Â  noteLabel.textContent = q.sym;

Â  Â  Â  Â  const input = document.createElement('input');
Â  Â  Â  Â  input.type = 'text';
Â  Â  Â  Â  input.className = 'answer';
Â  Â  Â  Â  input.placeholder = '';

Â  Â  Â  Â  const correctAnsDiv = document.createElement('div');
Â  Â  Â  Â  correctAnsDiv.className = 'correctAnswer';

Â  Â  Â  Â  container.appendChild(noteLabel);
Â  Â  Â  Â  container.appendChild(input);
Â  Â  Â  Â  container.appendChild(correctAnsDiv);

Â  Â  Â  Â  notesDiv.appendChild(container);
Â  Â  Â  }

Â  Â  Â  resultDiv.textContent = "";
Â  Â  Â  updateScore();

Â  Â  Â  timerInterval = setInterval(() => {
Â  Â  Â  Â  const elapsed = (performance.now() - startTime) / 1000;
Â  Â  Â  Â  timerDiv.textContent = `Timer: ${elapsed.toFixed(2)} s`;
Â  Â  Â  }, 100);
Â  Â  }

Â  Â  function checkAnswers() {
Â  Â  Â  if(!startTime) return;
Â  Â  Â  if(timerInterval) clearInterval(timerInterval);

Â  Â  Â  const inputs = document.querySelectorAll('.answer');
Â  Â  Â  const containers = notesDiv.children;
Â  Â  Â  let correct = 0;
Â  Â  Â  const tolerance = 0.01;

Â  Â  Â  inputs.forEach((input, idx) => {
Â  Â  Â  Â  let expectedRaw = questionNotes[idx].dur / baseNote.dur;
Â  Â  Â  Â  let expected = nearestAllowedAnswer(expectedRaw);
Â  Â  Â  Â  const val = parseAnswer(input.value);

Â  Â  Â  Â  const correctAnsDiv = containers[idx].querySelector('.correctAnswer');
Â  Â  Â  Â  
Â  Â  Â  Â  // Use the expected value for H-system generation
Â  Â  Â  Â  correctAnsDiv.textContent = `Answer: ${decimalToFraction(expected)} | H: ${durationToH(questionNotes[idx].dur)}`;

Â  Â  Â  Â  if (!isNaN(val) && Math.abs(val - expected) <= tolerance) {
Â  Â  Â  Â  Â  input.classList.remove('wrong');
Â  Â  Â  Â  Â  input.classList.add('correct');
Â  Â  Â  Â  Â  correctAnsDiv.style.color = 'black';
Â  Â  Â  Â  Â  correct++;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  input.classList.remove('correct');
Â  Â  Â  Â  Â  input.classList.add('wrong');
Â  Â  Â  Â  Â  correctAnsDiv.style.color = 'red';
Â  Â  Â  Â  }
Â  Â  Â  });

Â  Â  Â  const elapsed = (performance.now() - startTime) / 1000;

Â  Â  Â  resultDiv.textContent = `Correct: ${correct} / ${COUNT} | Total Time: ${elapsed.toFixed(2)} s`;

Â  Â  Â  if(correct > highScore) {
Â  Â  Â  Â  highScore = correct;
Â  Â  Â  Â  localStorage.setItem('rhythmHighScore', highScore);
Â  Â  Â  }
Â  Â  Â  if(correct === COUNT && (bestTime === 0 || elapsed < bestTime)) {
Â  Â  Â  Â  bestTime = elapsed;
Â  Â  Â  Â  localStorage.setItem('rhythmBestTime', bestTime);
Â  Â  Â  }

Â  Â  Â  updateScore();
Â  Â  }

Â  Â  function updateScore() {
Â  Â  Â  scoreDiv.textContent = `High Score: ${highScore} | Best Perfect Time: ${bestTime > 0 ? bestTime.toFixed(2) + ' s' : '--'}`;
Â  Â  }

Â  Â  document.addEventListener('keydown', e => {
Â  Â  Â  if(e.key === 'Enter') checkAnswers();
Â  Â  Â  else if(e.key.toLowerCase() === 'n') startQuiz();
Â  Â  });

Â  Â  startBtn.addEventListener('click', startQuiz);
Â  Â  submitBtn.addEventListener('click', checkAnswers);   

Â  Â  startQuiz();
Â  </script>
</body>
</html>

